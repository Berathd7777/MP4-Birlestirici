<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <title>🎥 MP4 Videoları Birleştirici</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  
  <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      font-family: "Roboto", sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }
    .container {
      background: white;
      border-radius: 20px;
      padding: 40px;
      max-width: 600px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    h1 {
      display: flex;
      align-items: center;
      gap: 12px;
      color: #667eea;
      font-size: 2rem;
      margin: 0 0 10px 0;
    }
    .subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 0.95rem;
    }
    .info-box {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      padding: 15px;
      margin-bottom: 25px;
      border-radius: 8px;
      font-size: 0.9rem;
      color: #1565c0;
    }
    .input-section {
      margin-bottom: 25px;
    }
    .input-section label {
      display: block;
      font-weight: 600;
      color: #333;
      margin-bottom: 10px;
      font-size: 1.05rem;
    }
    input[type="file"] {
      width: 100%;
      padding: 12px;
      border: 2px dashed #ddd;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s;
      background: #f9f9f9;
    }
    input[type="file"]:hover {
      border-color: #667eea;
      background: #f0f0ff;
    }
    input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 0.95rem;
      transition: all 0.3s;
    }
    input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
    }
    .divider {
      text-align: center;
      margin: 15px 0;
      color: #999;
      font-size: 0.9rem;
    }
    .btn {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 1.1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 30px;
    }
    .btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
    }
    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    #progress {
      margin-top: 30px;
      background: #f5f5f5;
      padding: 20px;
      border-radius: 12px;
      display: none;
    }
    .step {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 0;
      color: #666;
      transition: all 0.3s;
    }
    .step-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: all 0.3s;
    }
    .step.active {
      color: #667eea;
      font-weight: 600;
    }
    .step.active .step-icon {
      background: #667eea;
      color: white;
      animation: pulse 1.5s infinite;
    }
    .step.done {
      color: #4caf50;
    }
    .step.done .step-icon {
      background: #4caf50;
      color: white;
    }
    .step.error {
      color: #f44336;
    }
    .step.error .step-icon {
      background: #f44336;
      color: white;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    #log {
      margin-top: 15px;
      background: #2d2d2d;
      color: #0f0;
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 0.8rem;
      max-height: 200px;
      overflow-y: auto;
      display: none;
      white-space: pre-wrap;
      word-break: break-all;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>
      <span class="material-symbols-outlined">movie_filter</span>
      MP4 Birleştirici
    </h1>
    <p class="subtitle">Intro videonuzu ana videonun başına ekleyin</p>

    <div class="info-box">
      💡 <strong>MP4Box.js</strong> kullanılarak profesyonel video birleştirme
    </div>

    <div class="input-section">
      <label>🎬 Intro Videosu (Başa Eklenecek)</label>
      <input id="introFile" type="file" accept="video/mp4">
    </div>

    <div class="input-section">
      <label>🎥 Ana Video</label>
      <input id="mainFile" type="file" accept="video/mp4">
      <div class="divider">— veya —</div>
      <input id="videoUrl" type="text" placeholder="Herkese açık MP4 linki yapıştırın">
    </div>

    <button class="btn" id="runBtn">
      <span class="material-symbols-outlined">rocket_launch</span>
      Birleştir ve İndir
    </button>
    
    <div id="progress">
      <div class="step" data-step="0">
        <div class="step-icon">
          <span class="material-symbols-outlined">upload</span>
        </div>
        <span class="text">Intro videosu işleniyor...</span>
      </div>
      <div class="step" data-step="1">
        <div class="step-icon">
          <span class="material-symbols-outlined">download</span>
        </div>
        <span class="text">Ana video işleniyor...</span>
      </div>
      <div class="step" data-step="2">
        <div class="step-icon">
          <span class="material-symbols-outlined">merge</span>
        </div>
        <span class="text">Videolar birleştiriliyor...</span>
      </div>
      <div class="step" data-step="3">
        <div class="step-icon">
          <span class="material-symbols-outlined">download_done</span>
        </div>
        <span class="text">Video indiriliyor...</span>
      </div>
    </div>
    
    <div id="log"></div>
  </div>

  <script>
    const introInput = document.getElementById('introFile');
    const mainInput = document.getElementById('mainFile');
    const urlInput = document.getElementById('videoUrl');
    const runBtn = document.getElementById('runBtn');
    const logEl = document.getElementById('log');
    const progressDiv = document.getElementById('progress');
    const steps = document.querySelectorAll('.step');

    function log(msg) {
      console.log(msg);
      logEl.textContent += msg + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    function updateStep(index, status) {
      const step = steps[index];
      if (!step) return;
      
      steps.forEach((s, i) => {
        if (i < index && !s.classList.contains('error')) {
          s.classList.add('done');
          s.classList.remove('active');
          const icon = s.querySelector('.step-icon .material-symbols-outlined');
          icon.textContent = 'check_circle';
        } else {
          s.classList.remove('active', 'done', 'error');
        }
      });
      
      if (status === 'active') {
        step.classList.add('active');
        const icon = step.querySelector('.step-icon .material-symbols-outlined');
        if (index === 0) icon.textContent = 'upload';
        if (index === 1) icon.textContent = 'download';
        if (index === 2) icon.textContent = 'merge';
        if (index === 3) icon.textContent = 'download_done';
      } else if (status === 'done') {
        step.classList.add('done');
        const icon = step.querySelector('.step-icon .material-symbols-outlined');
        icon.textContent = 'check_circle';
      } else if (status === 'error') {
        step.classList.add('error');
        const icon = step.querySelector('.step-icon .material-symbols-outlined');
        icon.textContent = 'error';
      }
    }

    function checkInputsAndToggleRunButton() {
      const hasIntroFile = introInput.files.length > 0;
      const hasMainFile = mainInput.files.length > 0;
      const hasVideoUrl = urlInput.value.trim() !== '';

      runBtn.disabled = !(hasIntroFile && (hasMainFile || hasVideoUrl));
    }

    checkInputsAndToggleRunButton();
    introInput.onchange = checkInputsAndToggleRunButton;
    mainInput.onchange = checkInputsAndToggleRunButton;
    urlInput.oninput = checkInputsAndToggleRunButton;


    async function readFileAsArrayBuffer(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    async function fetchVideoAsArrayBuffer(url) {
      const response = await fetch(url);
      if (!response.ok) throw new Error('Video indirilemedi: ' + response.statusText);
      return await response.arrayBuffer();
    }

    async function parseAndCollectSamples(arrayBuffer, fileDescription = '') {
      return new Promise((resolve, reject) => {
        const mp4boxFile = MP4Box.createFile();
        let collectedSamples = {};
        let trackInfo = null;
        let finishedTracks = new Set();
        let totalTracks = 0;

        mp4boxFile.onReady = (info) => {
          log(`${fileDescription} video bilgisi alındı: ${info.tracks.length} track, süre: ${(info.duration / info.timescale).toFixed(2)} saniye.`);
          trackInfo = info;
          totalTracks = info.tracks.length;

          if (totalTracks === 0) {
              reject(new Error(`${fileDescription} için track bulunamadı. Bozuk veya desteklenmeyen video olabilir.`));
              return;
          }

          info.tracks.forEach(track => {
            // Debugging için track özelliklerini logla
            log(`DEBUG: ${fileDescription} Track ID: ${track.id}, track_type: ${track.track_type}, type: ${track.type}, Codec: ${track.codec}, Timescale: ${track.timescale}`);

            mp4boxFile.setExtractionOptions(track.id, null, { nbSamples: Infinity });
            collectedSamples[track.id] = [];
          });
          mp4boxFile.start();
        };

        mp4boxFile.onSamples = (track_id, user, samples) => {
          if (!collectedSamples[track_id]) {
            collectedSamples[track_id] = [];
          }
          collectedSamples[track_id] = collectedSamples[track_id].concat(samples);
          
          const track = trackInfo.tracks.find(t => t.id === track_id);
          if (track && collectedSamples[track_id].length >= track.nb_samples) {
            finishedTracks.add(track_id);
            if (finishedTracks.size === totalTracks) {
              log(`${fileDescription} için tüm örnekler toplandı.`);
              resolve({ mp4boxFile, info: trackInfo, collectedSamples });
            }
          }
        };

        mp4boxFile.onError = (e) => {
          reject(new Error(`${fileDescription} MP4 ayrıştırma hatası: ${e}`));
        };

        arrayBuffer.fileStart = 0;
        mp4boxFile.appendBuffer(arrayBuffer);
        mp4boxFile.flush();
      });
    }

    async function mergeVideos(introBuffer, mainBuffer) {
      log('MP4Box ile birleştirme başlıyor...');
      
      const { info: introInfo, collectedSamples: introCollectedSamples } = await parseAndCollectSamples(introBuffer, 'Intro');
      const { info: mainInfo, collectedSamples: mainCollectedSamples } = await parseAndCollectSamples(mainBuffer, 'Ana Video');

      log(`Intro süresi: ${(introInfo.duration / introInfo.timescale).toFixed(2)} saniye, Ana video süresi: ${(mainInfo.duration / mainInfo.timescale).toFixed(2)} saniye.`);
      
      const outputFile = MP4Box.createFile();
      const outputTrackMap = new Map();
      let anyTrackAdded = false; // En az bir track eklendi mi?

      introInfo.tracks.forEach(introTrack => {
        // --- Önemli: track_type kontrolü önce yapılmalı ve geçerli bir tip olmalı ---
        // MP4Box.js track nesnelerinde 'track_type' veya 'type' olabilir, ikisini de kontrol et
        const trackType = introTrack.track_type || introTrack.type; 

        if (!trackType || (trackType !== 'video' && trackType !== 'audio')) {
            log(`HATA: Intro track (ID ${introTrack.id}) için geçerli bir track tipi ('video' veya 'audio') bulunamadı (Tespit edilen Tip: ${trackType}). Bu track atlanacak.`);
            return; 
        }

        let description = null;
        if (introTrack.mdia && 
            introTrack.mdia.minf && 
            introTrack.mdia.minf.stbl && 
            introTrack.mdia.minf.stbl.stsd && 
            introTrack.mdia.minf.stbl.stsd.entries && 
            introTrack.mdia.minf.stbl.stsd.entries.length > 0) {
          description = introTrack.mdia.minf.stbl.stsd.entries[0];
        } else {
          log(`UYARI: Intro track (ID ${introTrack.id}, Tip ${trackType}) için codec açıklaması (stsd entry) bulunamadı. Bu track atlanacak.`);
          return;
        }
        
        const newTrackOptions = {
          type: trackType, // Geçerli trackType kullan
          codec: introTrack.codec,
          timescale: introTrack.timescale,
          duration: 0,
          description: description
        };

        if (introTrack.video) {
          newTrackOptions.width = introTrack.video.width;
          newTrackOptions.height = introTrack.video.height;
        }
        if (introTrack.audio) {
          newTrackOptions.samplerate = introTrack.audio.sample_rate;
          newTrackOptions.channel_count = introTrack.audio.channel_count;
        }
        if (introTrack.hdlr) {
          newTrackOptions.hdlr = introTrack.hdlr;
        }

        const newTrackId = outputFile.addTrack(newTrackOptions);
        
        if (typeof newTrackId === 'number' && newTrackId > 0) {
            outputTrackMap.set(introTrack.id, { outputTrackId: newTrackId, introDurationInOutputTimescale: 0 });
            log(`Intro track (ID ${introTrack.id}, Tip ${trackType}) için yeni çıkış track'i oluşturuldu (Çıkış ID ${newTrackId}).`);
            anyTrackAdded = true; // Başarılı bir track eklendi
        } else {
            log(`HATA: outputFile.addTrack intro track (ID ${introTrack.id}) için geçerli bir ID döndürmedi. Bu track atlanacak.`);
        }
      });

      for (const introTrackIdStr in introCollectedSamples) {
        const introTrackId = parseInt(introTrackIdStr);
        if (!outputTrackMap.has(introTrackId)) {
            continue;
        }
        const { outputTrackId } = outputTrackMap.get(introTrackId);
        const samples = introCollectedSamples[introTrackId];
        let currentTrackDuration = 0;

        samples.forEach(sample => {
          outputFile.addSample(outputTrackId, sample.data, {
            dts: sample.dts,
            cts: sample.cts,
            is_sync: sample.is_sync,
            duration: sample.duration,
            is_leading: sample.is_leading,
            is_depended_on: sample.is_depended_on,
            has_redundancy: sample.has_redundancy,
            degradation_priority: sample.degradation_priority,
            depends_on: sample.depends_on
          });
          currentTrackDuration += sample.duration;
        });
        outputTrackMap.get(introTrackId).introDurationInOutputTimescale = currentTrackDuration;
        log(`Çıkış track ${outputTrackId} için ${samples.length} intro örnek eklendi. Toplam süre: ${currentTrackDuration} birim.`);
      }

      mainInfo.tracks.forEach(mainTrack => {
        // mainTrack.track_type veya mainTrack.type kontrolü
        const mainTrackType = mainTrack.track_type || mainTrack.type;

        const matchingIntroTrack = introInfo.tracks.find(it => 
          (it.track_type === mainTrackType || it.type === mainTrackType) && // Hem intro hem main için type/track_type kontrolü
          it.codec === mainTrack.codec &&
          it.timescale === mainTrack.timescale
        );

        if (matchingIntroTrack && outputTrackMap.has(matchingIntroTrack.id)) {
          const { outputTrackId, introDurationInOutputTimescale } = outputTrackMap.get(matchingIntroTrack.id);
          const samples = mainCollectedSamples[mainTrack.id];

          samples.forEach(sample => {
            outputFile.addSample(outputTrackId, sample.data, {
              dts: sample.dts + introDurationInOutputTimescale,
              cts: sample.cts + introDurationInOutputTimescale,
              is_sync: sample.is_sync,
              duration: sample.duration,
              is_leading: sample.is_leading,
              is_depended_on: sample.is_depended_on,
              has_redundancy: sample.has_redundancy,
              degradation_priority: sample.degradation_priority,
              depends_on: sample.depends_on
            });
          });
          log(`Ana video track (ID ${mainTrack.id}, Tip ${mainTrackType}) örnekleri çıkış track ${outputTrackId}e ${introDurationInOutputTimescale} ofset ile eklendi.`);
          anyTrackAdded = true; // Ana videodan da track eklendiğinde işaretle
        } else {
          log(`UYARI: Ana video track (ID ${mainTrack.id}, Tip ${mainTrackType}, Codec ${mainTrack.codec}, Timescale ${mainTrack.timescale}) için uyumlu intro track bulunamadı veya intro track işlenmedi. Bu track atlanacak.`);
        }
      });
      
      // Eğer hiçbir track eklenemediyse finalize etme
      if (!anyTrackAdded) {
          throw new Error('Birleştirilecek geçerli track bulunamadı. Yüklenen MP4 dosyaları bozuk olabilir veya MP4Box.js tarafından desteklenmiyor.');
      }

      outputFile.finalize();
      log('MP4 dosyası birleştirme tamamlandı ve finalize edildi.');

      const mergedBuffer = outputFile.write('arraybuffer', {});
      log(`Birleştirilen dosya boyutu: ${(mergedBuffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
      return mergedBuffer;
    }

    runBtn.onclick = async () => {
      if (runBtn.disabled) {
        alert('Lütfen hem intro videosu hem de ana video (dosya veya link) seçin.');
        return;
      }

      runBtn.disabled = true;
      progressDiv.style.display = 'block';
      logEl.style.display = 'block';
      logEl.textContent = '';
      
      steps.forEach((step, index) => {
        step.classList.remove('active', 'done', 'error');
        const icon = step.querySelector('.step-icon .material-symbols-outlined');
        if (index === 0) icon.textContent = 'upload';
        if (index === 1) icon.textContent = 'download';
        if (index === 2) icon.textContent = 'merge';
        if (index === 3) icon.textContent = 'download_done';
      });


      try {
        updateStep(0, 'active');
        log('Intro videosu okunuyor...');
        const introBuffer = await readFileAsArrayBuffer(introInput.files[0]);
        log(`Intro yüklendi: ${(introBuffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
        updateStep(0, 'done');
        
        updateStep(1, 'active');
        let mainBuffer;
        if (mainInput.files[0]) {
          log('Ana video dosyadan okunuyor...');
          mainBuffer = await readFileAsArrayBuffer(mainInput.files[0]);
        } else {
          log('Ana video linkten indiriliyor...');
          mainBuffer = await fetchVideoAsArrayBuffer(urlInput.value.trim());
        }
        log(`Ana video yüklendi: ${(mainBuffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
        updateStep(1, 'done');
        
        updateStep(2, 'active');
        const mergedBuffer = await mergeVideos(introBuffer, mainBuffer);
        log(`Toplam boyut: ${(mergedBuffer.byteLength / 1024 / 1024).toFixed(2)} MB`);
        updateStep(2, 'done');
        
        updateStep(3, 'active');
        log('Video indiriliyor...');
        const blob = new Blob([mergedBuffer], { type: 'video/mp4' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'birlesik_video.mp4';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        log('İndirme başarılı!');
        updateStep(3, 'done');
        
        alert('✅ Video başarıyla birleştirildi ve indirildi!');
        
      } catch (error) {
        console.error('Hata:', error);
        log(`HATA: ${error.message}`);
        const activeStepIndex = Array.from(steps).findIndex(s => s.classList.contains('active'));
        if (activeStepIndex >= 0) updateStep(activeStepIndex, 'error');
        alert('❌ Bir hata oluştu: ' + error.message);
      } finally {
        runBtn.disabled = false;
        checkInputsAndToggleRunButton();
      }
    };
  </script>
</body>
</html>
